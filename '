import gleam/io
import gleam/int
import gleam/list

import gleam/otp/actor
import gleam/otp/static_supervisor as supervisor

import gleam/erlang/process

import topology

pub type PushSumMessage {

    InitActorState(neb_actors: List(process.Subject(PushSumMessage)))

    SumWeight(s: Float, w: Float)
}

pub type PushSumState {
    
    PushSumState(
        x: Float,
        w: Float,
        id: Int,
        change_count: Int,
        neb_list: List(process.Subject(PushSumMessage)),
    )
}
pub fn start(num_nodes: Int, topology: topology.Type) {

    let main_sub = process.new_subject()

    let sup_builder = supervisor.new(supervisor.OneForOne)

    let init_state = PushSumState(
                        0,
                        0,
                        0,
                        0,
                        neb_list: [],
                    )


    let #(builder, nodes_list) = topology.create_connections(
        num_nodes,
        init_state,
        handle_pushsum,
        sup_builder,
        topology,
    )

    let _ = supervisor.start(builder)
    let _ = list.fold(nodes_list, 1, fn (id, a) {

                    let topology.NodeMappings(parent_actor, neb_actors) = a

                    process.send(parent_actor, InitActorState(neb_actors, id))
                }
    )

    process.receive_forever(main_sub)
}

fn handle_pushsum(
    state: PushSumState,
    msg: PushSumMessage,
    ) -> actor.Next(PushSumState, PushSumMessage) {

    case msg {

        InitActorState(neb_actors, id) -> {

            let new_state = PushSumState(
                ..state,
                id: id,
                neb_list: neb_actors,
            )

            actor.continue(new_state)
        }

        SumWeight(s, w) -> {

            io.println("[PUSHSUM_ACTOR]: received s: " <> int.to_string(s) <> " ,w: " <> int.to_string(w))
            let new_state = PushSumState(
                ..state,
                s: state.s + s,
                w: state.w + w,
            )

            let send_idx = list.length(state.neb_list)
            |> int.random

            let #(_, send_actor) = list.fold_until(state.neb_list, *(0, tmp_actor), fn(tup, actor) {

                                                                    let #(idx, curr_actor) = tup
                                                                    case idx < send_idx {

                                                                        True -> Continue(#(
                                                                                            idx + 1, 
                                                                                            actor
                                                                                         )
                                                                                )

                                                                        False -> Stop(#(idx, actor))
                                                                    }
                                                                }
                                    )

            let send_s = {state.s + s} /. 2
            let send_w = {state.w + w} /. 2

            let sum_estimate = send_s /. send_w

            case float.absolute_value(sum_estimate -. state.sum_esitimate) <= 10.0e-10 {

                True -> {

                    case state.changed_count > 2 {

                        True -> {

                            io.println("[PUSHSUM_ACTOR]: " <> int.to_string(state.id) <> " has terminated")
                            actor.stop() 
                        }

                        False -> {

                            let new_state = PushSumState(
                                                ..state,
                                                changed_count: state.changed_count + 1,
                                            )

                            actor.continue(new_state)

                        } 
                    }
                }

                False -> {

                    let new_state = PushSumState(
                                        ..state,
                                        s: send_s,
                                        w: send_w,
                                        sum_estimate: 

                                    )
                }
            }

            let new_state = PushSumState(
                ..state,
                s: send_s,
                w: send_w,
            )


            process.send(send_actor, SumWeight(new

            actor.continue(state)
        }

    }
}
